import { StateMachine, State } from '../../src/util/StateMachine'

test('testSimple', () => {
  const start = new State('start')
  const intermediate = new State('intermediate')
  const end = new State('end')
  const sm = new StateMachine.Builder(start)
    .addTransition('begin', intermediate, start)
    .addTransition('finish', end, intermediate)
    .build()

  expect(sm.current).toBe(start)
  expect(sm.initial).toBe(start)
  expect(sm.transition('begin')).toBe(intermediate)
  expect(sm.current).toBe(intermediate)
  expect(sm.transition('nonsense')).toBeUndefined()
  expect(sm.current).toBe(intermediate)
  expect(sm.transition('begin')).toBeUndefined()
  expect(sm.current).toBe(intermediate)
  expect(sm.transition('intermediate')).toBeUndefined()
  expect(sm.current).toBe(intermediate)
  expect(sm.transition('finish')).toBe(end)
  expect(sm.current).toBe(end)
  expect(sm.initial).toBe(start)
})

test('testStateEvents', () => {
  let startEnter = 0; let intermediateEnter = 0; let endEnter = 0
  let startExit = 0; let intermediateExit = 0; let endExit = 0
  const start = new State('start', () => { startEnter++ }, () => { startExit++ })
  const intermediate = new State('intermediate', () => { intermediateEnter++ }, () => { intermediateExit++ })
  const end = new State('end', () => { endEnter++ }, () => { endExit++ })
  const sm = new StateMachine.Builder(start)
    .addTransition('begin', intermediate, start)
    .addTransition('finish', end, intermediate)
    .build()
  expect(startEnter).toBe(0)
  expect(startExit).toBe(0)
  expect(sm.transition('begin')).toBe(intermediate)
  expect(startEnter).toBe(0)
  expect(startExit).toBe(1)
  expect(intermediateEnter).toBe(1)
  expect(intermediateExit).toBe(0)
  expect(sm.transition('nonsense')).toBeUndefined()
  expect(sm.transition('begin')).toBeUndefined()
  expect(sm.transition('intermediate')).toBeUndefined()
  expect(startEnter).toBe(0)
  expect(startExit).toBe(1)
  expect(intermediateEnter).toBe(1)
  expect(intermediateExit).toBe(0)
  expect(sm.transition('finish')).toBe(end)
  expect(startEnter).toBe(0)
  expect(startExit).toBe(1)
  expect(intermediateEnter).toBe(1)
  expect(intermediateExit).toBe(1)
  expect(endEnter).toBe(1)
  expect(endExit).toBe(0)
})

test('testTransEvents', () => {
  let last = ''
  const start = new State('start')
  const intermediate = new State('intermediate')
  const end = new State('end')
  const sm = new StateMachine.Builder(start)
    .addTransitionEvent('begin', intermediate, (from: State, _to: State) => { last = from.name; return true }, start)
    .addTransitionEvent('finish', end, (from: State, _to: State) => { last = from.name; return true }, intermediate)
    .build()

  expect(last).toBe('')
  expect(sm.transition('begin')).toBe(intermediate)
  expect(last).toBe(start.name)
  expect(sm.transition('finish')).toBe(end)
  expect(last).toBe(intermediate.name)
})

test('testTransReject', () => {
  const start = new State('start')
  const intermediate = new State('intermediate')
  const end = new State('end')
  const sm = new StateMachine.Builder(start)
    .addTransition('begin', intermediate, start)
    .addTransitionEvent('finish', end, () => { return false }, intermediate)
    .build()

  expect(sm.current).toBe(start)
  expect(sm.transition('begin')).toBe(intermediate)
  expect(sm.current).toBe(intermediate)
  expect(sm.transition('finish')).toBeUndefined()
  expect(sm.current).toBe(intermediate)
})

test('testSinkState', () => {
  const start = new State('start')
  const intermediate = new State('intermediate')
  const end = new State('end')
  const sm = new StateMachine.Builder(start)
    .addTransition('begin', intermediate, start)
    .addTransition('finish', end, intermediate, start)
    .build()

  expect(sm.current).toBe(start)
  expect(sm.transition('begin')).toBe(intermediate)
  expect(sm.transition('finish')).toBe(end)
  sm.reset()
  expect(sm.current).toBe(start)
  expect(sm.transition('finish')).toBe(end)
})
